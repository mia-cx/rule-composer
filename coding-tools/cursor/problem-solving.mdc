---
description: >-
  Problem-solving protocol — how to approach coding, debugging, building
  features, testing, and security updates
alwaysApply: true
---
# Problem-Solving Protocol

## Before Writing Code

1. Read the relevant files first. Do not guess at structure or APIs.
2. State your plan concisely — what you'll change and why.
3. If there are multiple valid approaches, name them, explain trade-offs, and pick one with a reason.
4. **Copy/move files via CLI** — Use `cp`, `mv`, `rsync` instead of reading and rewriting file contents. Don't waste tokens reproducing what the filesystem can handle.

## When Debugging

1. **Reproduce first.** Confirm the actual error or behavior before proposing a fix.
2. **Simple causes first.** Check for typos, wrong file paths, missing imports, stale caches, incorrect variable names, and version mismatches before investigating complex causes. Most real-world bugs are simple oversights.
3. **Track what you've tried.** Before each attempt, list prior failed approaches and *why* they failed. Never retry an approach that already failed unless circumstances changed.
4. **Two-strike rule.** After two failed attempts, stop and:
   - Summarize: what you know, what you've tried, what the results were.
   - Re-examine assumptions — at least one is likely wrong.
   - Consider causes in a different category (logic → configuration, code → data).
   - If still stuck, ask the user. Do not silently attempt a third variation of the same idea.
5. **Never loop.** About to retry a variation of something that failed? Change direction instead of trying harder.

## Dependabot / Security Branches

When working on a Dependabot or security-related branch:

1. Check the last 3 commits for context.
2. Read the linked issue/PR for CVE identifiers and severity.
3. Search the web for the CVE — check for recommended fixes or migration steps beyond the version bump.
4. Verify the app builds and tests pass after the update.

## When Building Features

1. Implement the minimal working version first.
2. Verify it works (or ask the user to verify) before adding complexity.
3. If you leave a TODO, flag it explicitly and address it before finishing.

## Testing & Verification

1. **Write tests alongside implementation.** Each key module, endpoint, or piece of functionality gets unit tests (Vitest). Don't defer testing to the end.
2. **Tests must pass.** Run and confirm. A failing test is worse than no test.
3. **The app must build and run.** Verify before considering a task complete. Warnings are acceptable — many frameworks emit warnings that aren't actionable issues.
